"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTSClient = void 0;
const axios_1 = __importDefault(require("axios"));
const client_1 = require("../core/client");
const exceptions_1 = require("../core/exceptions");
const models_1 = require("./models");
class TTSClient extends client_1.BaseClient {
    constructor(config, customHeaders, verbose = false) {
        super(config, customHeaders, verbose);
    }
    async synthesize(request) {
        if (!request.text && !request.ssml) {
            throw new exceptions_1.ValidationError('必须提供 text 或 ssml 其中之一');
        }
        const apiRequest = (0, models_1.buildTTSApiRequest)(request);
        const headers = {
            ...this.config.getHeaders(),
            Connection: 'keep-alive',
        };
        try {
            const response = await axios_1.default.post(`${this.config.baseUrl}/api/v3/tts/unidirectional`, apiRequest, {
                headers,
                responseType: 'stream',
                timeout: this.config.timeout,
            });
            return await this.processStreamResponse(response);
        }
        catch (error) {
            if (error.response) {
                throw new exceptions_1.APIError(`TTS 请求失败: ${error.message}`, error.response.status, error.response.data);
            }
            throw new exceptions_1.APIError(`TTS 请求异常: ${error.message}`, 500);
        }
    }
    async processStreamResponse(response) {
        return new Promise((resolve, reject) => {
            let audioUri = '';
            let totalAudioSize = 0;
            let buffer = '';
            response.data.on('data', (chunk) => {
                buffer += chunk.toString('utf-8');
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                for (const line of lines) {
                    if (!line.trim() || !line.startsWith('data:')) {
                        continue;
                    }
                    try {
                        const jsonStr = line.replace('data:', '').trim();
                        if (!jsonStr)
                            continue;
                        const data = JSON.parse(jsonStr);
                        if (data.code === 0 && data.data) {
                            const audioChunk = Buffer.from(data.data, 'base64');
                            totalAudioSize += audioChunk.length;
                        }
                        else if (data.code === 20000000) {
                            if (data.url) {
                                audioUri = data.url;
                            }
                            resolve({
                                audioUri,
                                audioSize: totalAudioSize,
                            });
                            return;
                        }
                        else if (data.code > 0) {
                            reject(new exceptions_1.APIError(`合成音频失败: ${data.message || ''}`, data.code));
                            return;
                        }
                    }
                    catch (e) {
                        reject(new exceptions_1.APIError(`响应解析失败: ${e.message}`, 500));
                        return;
                    }
                }
            });
            response.data.on('end', () => {
                if (!audioUri && totalAudioSize === 0) {
                    reject(new exceptions_1.APIError('未收到完整的音频数据', 500));
                }
                else {
                    resolve({
                        audioUri,
                        audioSize: totalAudioSize,
                    });
                }
            });
            response.data.on('error', (error) => {
                reject(new exceptions_1.APIError(`流处理错误: ${error.message}`, 500));
            });
        });
    }
}
exports.TTSClient = TTSClient;
//# sourceMappingURL=tts.js.map