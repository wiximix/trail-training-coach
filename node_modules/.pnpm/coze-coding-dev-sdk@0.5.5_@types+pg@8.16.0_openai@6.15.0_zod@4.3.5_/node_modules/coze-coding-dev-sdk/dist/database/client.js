"use strict";
/**
 * Database client module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadEnv = loadEnv;
exports.getDbUrl = getDbUrl;
exports.getPool = getPool;
exports.getDb = getDb;
exports.getClient = getClient;
exports.closePool = closePool;
const node_postgres_1 = require("drizzle-orm/node-postgres");
const pg_1 = __importDefault(require("pg"));
const child_process_1 = require("child_process");
const models_1 = require("./models");
let envLoaded = false;
function loadEnv() {
    if (envLoaded || process.env.PGDATABASE_URL) {
        return;
    }
    try {
        try {
            require('dotenv').config();
            if (process.env.PGDATABASE_URL) {
                envLoaded = true;
                return;
            }
        }
        catch {
            // dotenv not available
        }
        const pythonCode = `
import os
import sys
try:
    from coze_workload_identity import Client
    client = Client()
    env_vars = client.get_project_env_vars()
    client.close()
    for env_var in env_vars:
        print(f"{env_var.key}={env_var.value}")
except Exception as e:
    print(f"# Error: {e}", file=sys.stderr)
`;
        const output = (0, child_process_1.execSync)(`python3 -c '${pythonCode.replace(/'/g, "'\"'\"'")}'`, {
            encoding: 'utf-8',
            timeout: 10000,
            stdio: ['pipe', 'pipe', 'pipe'],
        });
        const lines = output.trim().split('\n');
        for (const line of lines) {
            if (line.startsWith('#'))
                continue;
            const eqIndex = line.indexOf('=');
            if (eqIndex > 0) {
                const key = line.substring(0, eqIndex);
                let value = line.substring(eqIndex + 1);
                if ((value.startsWith("'") && value.endsWith("'")) ||
                    (value.startsWith('"') && value.endsWith('"'))) {
                    value = value.slice(1, -1);
                }
                if (!process.env[key]) {
                    process.env[key] = value;
                }
            }
        }
        envLoaded = true;
    }
    catch {
        // Silently fail
    }
}
function getDbUrl() {
    loadEnv();
    let url = process.env.PGDATABASE_URL || '';
    if (!url) {
        throw new Error('Database URL not configured. Set PGDATABASE_URL environment variable.\n' +
            'Did you create a database? You can create one via the Coze Coding platform.');
    }
    if (url.startsWith('postgres://')) {
        url = 'postgresql://' + url.substring('postgres://'.length);
    }
    return url;
}
let pool = null;
let db = null;
async function createPoolWithRetry(config) {
    const url = getDbUrl();
    const newPool = new pg_1.default.Pool({
        connectionString: url,
        max: config?.maxConnections ?? models_1.DatabaseConfig.MAX_CONNECTIONS,
        idleTimeoutMillis: config?.idleTimeoutMillis ?? models_1.DatabaseConfig.IDLE_TIMEOUT_MILLIS,
        connectionTimeoutMillis: config?.connectionTimeoutMillis ?? models_1.DatabaseConfig.CONNECTION_TIMEOUT_MILLIS,
    });
    const startTime = Date.now();
    let lastError = null;
    while (Date.now() - startTime < models_1.DatabaseConfig.MAX_RETRY_TIME) {
        try {
            const client = await newPool.connect();
            await client.query('SELECT 1');
            client.release();
            return newPool;
        }
        catch (e) {
            lastError = e;
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            console.warn(`Database connection failed, retrying... (elapsed: ${elapsed}s)`);
            await new Promise((resolve) => setTimeout(resolve, Math.min(1000, models_1.DatabaseConfig.MAX_RETRY_TIME - (Date.now() - startTime))));
        }
    }
    console.error(`Database connection failed after ${models_1.DatabaseConfig.MAX_RETRY_TIME / 1000}s: ${lastError?.message}`);
    throw lastError;
}
async function getPool(config) {
    loadEnv();
    if (!pool) {
        pool = await createPoolWithRetry(config);
    }
    return pool;
}
async function getDb(schema) {
    if (!db) {
        const p = await getPool();
        db = schema ? (0, node_postgres_1.drizzle)(p, { schema }) : (0, node_postgres_1.drizzle)(p);
    }
    return db;
}
async function getClient() {
    const p = await getPool();
    return p.connect();
}
async function closePool() {
    if (pool) {
        await pool.end();
        pool = null;
        db = null;
    }
}
//# sourceMappingURL=client.js.map