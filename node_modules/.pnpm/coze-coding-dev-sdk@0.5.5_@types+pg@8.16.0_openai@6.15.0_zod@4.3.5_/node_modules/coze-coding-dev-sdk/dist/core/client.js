"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseClient = void 0;
const axios_1 = __importDefault(require("axios"));
const config_1 = require("./config");
const exceptions_1 = require("./exceptions");
const version_1 = require("../version");
class BaseClient {
    constructor(config, customHeaders, verbose = false) {
        this.config = config || new config_1.Config();
        this.verbose = verbose;
        this.axiosInstance = axios_1.default.create({
            timeout: this.config.timeout,
            headers: {
                'Authorization': `Bearer ${this.config.apiKey}`,
                'Content-Type': 'application/json',
                'X-Client-Sdk': `coze-coding-dev-sdk-typescript/${version_1.VERSION}`,
                ...customHeaders,
            },
        });
    }
    async request(method, url, data, config) {
        let lastError = null;
        for (let attempt = 0; attempt <= this.config.retryTimes; attempt++) {
            try {
                if (attempt === 0 && this.verbose) {
                    this.logRequest(method, url, data, config);
                }
                const response = await this.axiosInstance.request({
                    method,
                    url,
                    data,
                    ...config,
                });
                if (attempt === 0 && this.verbose) {
                    this.logResponse(response);
                }
                return response.data;
            }
            catch (error) {
                lastError = error;
                if (error.response) {
                    const statusCode = error.response.status;
                    if (statusCode >= 400 && statusCode < 500 && statusCode !== 429) {
                        throw new exceptions_1.APIError(error.response.data?.message || error.message, statusCode, error.response.data);
                    }
                }
                if (attempt < this.config.retryTimes) {
                    await this.sleep(this.config.retryDelay * 1000 * (attempt + 1));
                }
            }
        }
        if (lastError) {
            if (axios_1.default.isAxiosError(lastError) && lastError.response) {
                throw new exceptions_1.APIError(lastError.response.data?.message || lastError.message, lastError.response.status, lastError.response.data);
            }
            else {
                throw new exceptions_1.NetworkError(lastError.message);
            }
        }
        throw new exceptions_1.NetworkError('Request failed after retries');
    }
    async requestWithResponse(method, url, data, config) {
        let lastError = null;
        for (let attempt = 0; attempt <= this.config.retryTimes; attempt++) {
            try {
                if (attempt === 0 && this.verbose) {
                    this.logRequest(method, url, data, config);
                }
                const response = await this.axiosInstance.request({
                    method,
                    url,
                    data,
                    ...config,
                });
                if (attempt === 0 && this.verbose) {
                    this.logResponse(response);
                }
                return response;
            }
            catch (error) {
                lastError = error;
                if (error.response) {
                    const statusCode = error.response.status;
                    if (statusCode >= 400 && statusCode < 500 && statusCode !== 429) {
                        throw new exceptions_1.APIError(error.response.data?.message || error.message, statusCode, error.response.data);
                    }
                }
                if (attempt < this.config.retryTimes) {
                    await this.sleep(this.config.retryDelay * 1000 * (attempt + 1));
                }
            }
        }
        if (lastError) {
            if (axios_1.default.isAxiosError(lastError) && lastError.response) {
                throw new exceptions_1.APIError(lastError.response.data?.message || lastError.message, lastError.response.status, lastError.response.data);
            }
            else {
                throw new exceptions_1.NetworkError(lastError.message);
            }
        }
        throw new exceptions_1.NetworkError('Request failed after retries');
    }
    sanitizeHeaders(headers) {
        const sensitiveKeys = [
            'authorization',
            'auth',
            'api-key',
            'apikey',
            'api_key',
            'x-api-key',
            'x-auth-token',
            'token',
            'secret',
            'password',
            'passwd',
            'pwd',
        ];
        const sanitized = {};
        for (const [key, value] of Object.entries(headers)) {
            const lowerKey = key.toLowerCase();
            const isSensitive = sensitiveKeys.some(sensitiveKey => lowerKey.includes(sensitiveKey));
            if (isSensitive) {
                sanitized[key] = '***';
            }
            else {
                sanitized[key] = value;
            }
        }
        return sanitized;
    }
    logRequest(method, url, data, config) {
        console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ðŸ“¤ HTTP Request');
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log(`Method: ${method}`);
        console.log(`URL: ${url}`);
        const headers = {};
        const commonHeaders = this.axiosInstance.defaults.headers.common || {};
        const methodHeaders = this.axiosInstance.defaults.headers[method.toLowerCase()] || {};
        const configHeaders = config?.headers || {};
        Object.assign(headers, commonHeaders, methodHeaders, configHeaders);
        const sanitizedHeaders = this.sanitizeHeaders(headers);
        console.log('\nHeaders:');
        for (const [key, value] of Object.entries(sanitizedHeaders)) {
            console.log(`  ${key}: ${value}`);
        }
        if (data) {
            console.log('\nBody:');
            console.log(JSON.stringify(data, null, 2));
        }
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    }
    logResponse(response) {
        console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ðŸ“¥ HTTP Response');
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log(`Status: ${response.status} ${response.statusText}`);
        if (response.headers) {
            console.log('\nHeaders:');
            for (const [key, value] of Object.entries(response.headers)) {
                console.log(`  ${key}: ${value}`);
            }
        }
        if (response.data) {
            console.log('\nBody:');
            const dataStr = typeof response.data === 'string'
                ? response.data
                : JSON.stringify(response.data, null, 2);
            const truncated = dataStr.length > 1000
                ? dataStr.substring(0, 1000) + '\n... (truncated)'
                : dataStr;
            console.log(truncated);
        }
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.BaseClient = BaseClient;
//# sourceMappingURL=client.js.map