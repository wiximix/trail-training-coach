#!/bin/bash

# Git pre-push hook
# 在每次 git push 前自动执行
# 功能: 自动归档 commit_log.md

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${GREEN}[pre-push]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[pre-push]${NC} $1"
}

# 获取脚本所在目录
HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${HOOK_DIR}/../.." && pwd)"

# 归档脚本路径
ARCHIVE_SCRIPT="${PROJECT_ROOT}/scripts/archive-commit-log.sh"

# commit_log.md 文件路径
COMMIT_LOG_FILE="${PROJECT_ROOT}/commit_log.md"

# 检查 commit_log.md 是否有未暂存的更改
LOG_HAS_CHANGES=false
if [ -f "${COMMIT_LOG_FILE}" ] && [ -s "${COMMIT_LOG_FILE}" ]; then
    # 只检查未暂存的更改（已暂存的更改会在本次 commit 中提交）
    UNSTAGED_CHANGES=$(git diff --name-only | grep -E "^commit_log\.md$" || true)
    if [ -n "${UNSTAGED_CHANGES}" ]; then
        log_warn "commit_log.md 有未暂存的更改"
        LOG_HAS_CHANGES=true
    fi
fi

# 如果 commit_log.md 有更改，执行归档
if [ "${LOG_HAS_CHANGES}" = true ]; then
    echo
    log_info "=== 检测到 commit_log.md 更新，开始归档 ==="
    echo

    # 执行归档脚本
    if [ -f "${ARCHIVE_SCRIPT}" ]; then
        bash "${ARCHIVE_SCRIPT}" "$@" || {
            echo
            log_warn "归档脚本执行失败，但 push 操作将继续"
            echo
        }
    else
        log_warn "未找到归档脚本: ${ARCHIVE_SCRIPT}"
        log_warn "跳过归档操作"
    fi

    echo
    log_info "归档完成，继续 push 操作"
    echo
else
    # 没有更改，不执行归档
    log_info "commit_log.md 无更新，跳过归档"
fi

# 检查是否有未提交的更改
UNCOMMITTED_CHANGES=$(git status --porcelain | wc -l)
if [ "${UNCOMMITTED_CHANGES}" -gt 0 ]; then
    echo
    log_warn "警告: 检测到 ${UNCOMMITTED_CHANGES} 个未提交的更改"
    echo
    git status --short
    echo
    read -p "是否继续 push？(y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "取消 push 操作"
        exit 1
    fi
    echo
fi

# 继续执行 push 操作
exit 0
